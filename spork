#!/usr/bin/env perl
use warnings;
use strict;
use Getopt::Long qw(:config bundling);

#params:
# -f --file <filename>: file containing the list of servers
# -t --threaded #: 		whether to go threaded, and optionally how many threads
# -u --user <username>: username to use if not same as current user

my $username=getlogin;
my $threaded=0;
my $filename="";
my $debug	=0;
my $notint	=0; #not interactive - shortcut for threading and running without needing interaction

GetOptions (
	'username|u=s'	=> \$username,
	'threaded|t:1'	=> \$threaded,
	'filename|f=s'	=> \$filename,
	'debug|d:1'		=> \$debug,
	'notinteractive|n'=> \$notint,
	);

my $command=shift || usage();
#check for passed values - which will be used as a list of machine names in lieu of the filename arg
my @lines=();
if(!-t STDIN){@lines=<>;}
if(!@lines)
{
	open(F,$filename)
		or die("Couldn't open file $filename for reading: $!\n");
	@lines=<F>;
	close(F)
		or die("Couldn't close filehandle for $filename: $!\n");
	chomp(@lines);
}
@lines=map{$a=$_;$a=~s/\s+//g;$a if $a}@lines; #no whitespace in name, and no empty lines
print "username=$username, threaded=$threaded, filename=$filename, command=$command\n" if $debug;
print "Host list:".join(",",@lines)."\n" if $debug;
if($threaded)
{
		use Threadeach;
		if($threaded == -1)
		{
			Threadeach::threadall(\&runcmd_not_int,@lines);
		}
		elsif($threaded > 1) #means they've specified the number of threads
		{
			Threadeach::threadsome(\&runcmd_not_int,$threaded,@lines);
		}
		else
		{
			Threadeach::threadeach(\&runcmd_not_int,@lines);
		}
}
else
{
	foreach my $line(@lines)
	{
		if($notint){&runcmd_not_int($line,$command);}
		else{&runcmd_int($line,$command);}
	}
}

sub runcmd_int
{
	my $host=shift || die "No host passed to runcmd_int\n";
	#what's the best way to run here?
	print "$host: ";
	system("ssh $username\@$host \"$command\"");
}
#if it's not interactive, we can make the output nicer.  :)
sub runcmd_not_int
{
	my $host=shift || die ("Error no host passed to sub runcmd_not_int!\n");
	open(CMD,"ssh $username\@$host \"$command\" |")
		or die("Couldn't open command: $!");
	while(<CMD>)
	{
		my $ret=$_;
		chomp($ret);
		print "$host: $ret\n";
	}
}

sub usage
{
	print <<cEND;
Usage: $0 -f <filename> "command to run on remote host"
Options:
  -u/--username username to run as
  -t/--threaded Whether to run as threaded, optionally with the # of threads, or -1 to run all
  -f/--filename filename to use as list of hosts
Example:
  $0 -d -t 8 -u root -f myhostsfile "uptime"
    will go to all the hosts listed in myhostsfile and run the "uptime" command with max 8 parallel threads
  grep nameserver /etc/resolv.conf | awk '{print $2}' | $0 'host google.com'
    will go to all the nameservers in resolv.conf one at a time and run 'host google.com' on them
cEND

exit();
}
